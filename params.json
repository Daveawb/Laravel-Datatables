{"name":"Laravel-datatables","tagline":"A datatables package for Laravel ~4.1.0","body":"Laravel-Datatables \r\n==================\r\n[![Build Status](https://travis-ci.org/Daveawb/Laravel-Datatables.svg?branch=master)](https://travis-ci.org/Daveawb/Laravel-Datatables) [![Coverage Status](https://coveralls.io/repos/Daveawb/Laravel-Datatables/badge.png?branch=development)](https://coveralls.io/r/Daveawb/Laravel-Datatables?branch=development)\r\n\r\n#Introduction\r\nThis project is aimed at anyone using the fantastic dataTables jQuery plugin written by [SpryMedia](http://sprymedia.co.uk/) and Laravel 4.1 or greater. It was written originally for dataTables 1.9.x, however since 1.10.x has now been released with a new API and data structure there will be updates to allow you to make use of the new syntax in the near future. If you haven't used datatables before check it out at [Datatables.net](http://datatables.net/).\r\n\r\nFor the mean time you will need to use the old 1.9.x API that is still compatable with 1.10.x. You can find the docs at [the legacy Datatables site](http://legacy.datatables.net/).\r\n\r\n## Supported datatables components\r\n- Client side column re-ordering\r\n- Per column sorting\r\n- Global search\r\n- Search in a specific column\r\n- Set number of rows to return\r\n- Filtered and Total rows\r\n\r\n## Supported features \r\n- MongoDb support\r\n- Eloquent and Query builder support\r\n- Custom DB driver support\r\n- Basic column decoration\r\n- Custom column decoration / manipulation using closures\r\n- Basic multi field support\r\n    - no support for search and ordering on multiple columns yet\r\n\r\nAll components above require no extra configuration (other than database drivers). In a future release there will be the ability to send back named attributes per row such as `DT_RowClass` and any other data you want to return by row or if you want in the top level of the returned JSON for global data.\r\n\r\n#Requirements\r\n- >= PHP 5.4\r\n- >= Laravel 4.1.*\r\n\r\n#Installation\r\n##Composer\r\nAdd the following to your composer.json file\r\n\r\n````json\r\n{\r\n    \"require\": {\r\n        \"daveawb/datatables\": \"0.3.*\"\r\n    },\r\n}\r\n````\r\n\r\n##Add the Laravel service provider\r\nOnce you have run a `composer update` you will need to add the service provider.\r\n\r\nOpen up `config/app.php` and add the followng to the service providers array.\r\n\r\n````\r\n\"Daveawb\\Datatables\\DatatablesServiceProvider\"\r\n````\r\n\r\n##Publish package configuration\r\nFrom the command line `php artisan config:publish daveawb\\datatables`\r\n\r\n##Add the Laravel facade (optional)\r\n\r\nAdd the following to your `config/app.php` alias' array.\r\n\r\n````\r\n\"Datatable\" => \"Daveawb\\Datatables\\Facades\\Datatable\"\r\n````\r\n\r\n#Basic Usage\r\n````php\r\nRoute::post('datatable', function()\r\n{\r\n    $datatable = App::make(\"Daveawb\\Datatables\\Datatable\");\r\n    \r\n    $datatable->query(new User());\r\n\r\n    $datatable->columns(array(\r\n        \"first_name\",\r\n        \"last_name\",\r\n        \"username\",\r\n        \"verified\",\r\n        \"created_at\",\r\n        \"updated_at\"\r\n    ));\r\n    \r\n    return $datatable->result();\r\n});\r\n````\r\n\r\nThe columns method takes an array in the order you wish to send data back to the client. Each field maps to a field in the database available from the query you've injected.\r\n\r\nThe query method maps directly to the driver being used, as standard Eloquent models/builders and query builders are accepted:\r\n`Illuminate\\Database\\Eloquent\\Model` or `Illuminate\\Database\\Eloquent\\Builder`\r\n\r\nExample passing in a standard query builder.\r\n\r\n````php\r\nRoute::post('datatable', function()\r\n{\r\n    $datatable = App::make(\"Daveawb\\Datatables\\Datatable\");\r\n    \r\n    $datatable->query(DB::table('users'));\r\n\r\n    $datatable->columns(array(\r\n        \"first_name\",\r\n        \"last_name\",\r\n        \"username\",\r\n        \"verified\",\r\n        \"created_at\",\r\n        \"updated_at\"\r\n    ));\r\n    \r\n    return $datatable->result();\r\n});\r\n````\r\n\r\nAs thequery method accepts builder instances you can pass a predefined query before inserting it into the datatables package.\r\n\r\n````php\r\n$user = new User();\r\n$datatable->query($user->with('roles'));\r\n````\r\n\r\nOr using a standard query builder\r\n\r\n````php\r\n$datatable->query(DB::table('users')->where('deleted_at', '!=', 'NULL');\r\n````\r\n\r\n##Column interpretation / decoration\r\nEvery now and again you find that you need to merge the contents of fields or wrap them in HTML tags. This is where column interpretation / decoration comes in. Each of the decorations / interpretations are executed in the order you declare them. If you use two or more decorators on the same column, the result of the previous operation will be the value passed into the next decorator. This will allow you to build some complex decorations with a few core methods.\r\n\r\n**At present the first field declared is modified to hold the result of the combination of the two fields.**\r\n\r\n###Built in methods\r\n\r\n- Append\r\n- Prepend\r\n- Combine\r\n\r\n####Append\r\nAppend takes two arguments, the value to append and an optional separator.\r\n````php\r\n$datatable->columns(array(\r\n    // Note the space as second arg to append\r\n    array(\"first_name\", array(\"append\" => \"eats lots of pies, \"))\r\n));\r\n\r\n// If value of first_name is David the output would be\r\narray(\r\n    // Only the aaData values are shown here\r\n    \"aaData\" => array(\r\n        array(\r\n            \"first_name\" => \"David eats lots of pies\"\r\n        )\r\n    )\r\n);\r\n````\r\n**If your data to append === a key in the data from the database, it will be swapped out for that value**\r\n\r\n####Prepend\r\nPrepend takes two arguments, the value to prepend and an optional separator.\r\n````php\r\n$datatable->columns(array(\r\n    // Note the space as second arg to prepend\r\n    array(\"last_name\", array(\"prepend\" => \"Mr, \"))\r\n));\r\n\r\n// If value of last_name is Barker the output would be\r\narray(\r\n    // Only the aaData values are shown here\r\n    \"aaData\" => array(\r\n        array(\r\n            \"last_name\" => \"Mr Barker\"\r\n        )\r\n    )\r\n);\r\n````\r\n\r\n**If your data to prepend === a key in the data from the database, it will be swapped out for that value**\r\n\r\n####Combine\r\n````php\r\n$datatable->columns(array(\r\n    // Note the space as the last arg to combine\r\n    array(\"first_name\", \"last_name\", array(\"combine\" => \"first_name,last_name, \"))\r\n));\r\n````\r\nInstead of passing a string into the column we pass an array, with the last value always being an array that declares the decorators/interpreters you want to use with their unique settings. Each interpreter will have separate documentation in the future. For now only `combine` is available and takes in field names to combine with the last value being the seperator. If the database values returned are `first_name = \"David\"` and `last_name = \"Barker\"` the above code would produce:\r\n\r\n````php\r\narray(\r\n    // Only the aaData values are shown here\r\n    \"aaData\" => array(\r\n        array(\r\n            \"first_name\" => \"David Barker\"\r\n        )\r\n    )\r\n);\r\n````\r\nYou can combine as many fields as you like, you are not limited to two.\r\n\r\n####Chaining interpreters / decorators\r\nYou can chain as many decorators together as you like, interpreters are slightly different as they have terminal and non terminal expressions. For now all interpreters are terminal expressions and treat each call as a new interpretation.\r\n\r\n````php\r\n$datatable->columns(array(\r\n    array(\r\n        \"first_name\", \r\n        \"last_name\", \r\n        array(\r\n            \"combine\" => \"first_name,last_name, \",\r\n            \"append\" => \"Mr, \",\r\n            \"prepend\" => \"BSc(hons), \"\r\n        )\r\n    );\r\n));\r\n\r\n// The result of the above would be\r\narray(\r\n    // Only the aaData values are shown here\r\n    \"aaData\" => array(\r\n        array(\r\n            \"first_name\" => \"Mr David Barker BSc(hons)\"\r\n        )\r\n    )\r\n);\r\n````\r\n\r\n###Use a closure on your column!\r\nTo allow some fine grained control over the contents of a specific field you can use a closure instead / as well as the decorators. You must declare a closure **BEFORE** any decorators / interpreters. Also be aware your closure will be executed **AFTER** decorators / interpretaters have been run.\r\n\r\n````php\r\n$datatable->columns(array(\r\n    array(\r\n        \"first_name\", \r\n        function($field, $databaseRowData)\r\n        {\r\n            return sprintf(\r\n                \"A modified first_name field, it was %s before\",\r\n                $databaseRowData->$field\r\n            );\r\n        }\r\n    );\r\n));\r\n\r\n// The result of the above would be\r\narray(\r\n    \"aaData\" => array(\r\n        array(\r\n            \"first_name\" => \"A modified first_name field, it was David before\"\r\n        )\r\n    )\r\n);\r\n````\r\n\r\nPlease note that to date the second field is not subject to any search, ordering or any other database related functionality. This will more than likely be added in the future.\r\n\r\n#Custom database drivers\r\nThe built in driver will allow you to use Eloquent models and builders as well as standard Query builders as the base query input into the package. Each driver extends `Daveawb\\Datatables\\Driver` that sets standard methods for all drivers such as setting the column factory and implements abstract methods.\r\n\r\nThere are two drivers that are bundled with this package:\r\n- The default Laravel driver\r\n- MongoDB driver\r\n\r\nAny driver can be swapped in to replace the default driver at runtime using the `driver` method.\r\n\r\n##Using the MongoDB driver\r\n\r\n````php\r\n$datatable = App::make(\"Daveawb\\Datatables\\Datatable\");\r\n\r\n$datatable->driver(new Daveawb\\Datatables\\Drivers\\Mongo());\r\n\r\n````\r\n\r\nRather than using the `query` method to pass in an instance of Eloquent or a Query builder, we have a few different options for Mongo.\r\n\r\n###Configuration\r\nIf you haven't already published the packages config, now is a good time to do it. From the command line `php artisan config:publish daveawb/datatables`.\r\n\r\nThe configuration file has settings for your MongoDB database, replica sets and multiple servers are supported as well as authorisation, just set the configuration options accordingly.\r\n\r\n###Building the query\r\n\r\n####Using a collection\r\n````php\r\n$datatable->query(\"collection\"); // Pass in a collection name\r\n````\r\n\r\n####Setting predefined query data\r\n````php\r\n$datatable->query(array(\"collection\", function()\r\n{\r\n    return array(\r\n        '$or' => array(\r\n            array(\"first_name\" : \"David\")\r\n        )\r\n    );\r\n});\r\n````\r\n**The closure must always return an array**\r\n\r\n####Getting results\r\nEverything else is exactly the same, set columns with interpreters / decorators any way you wish and just return `$datatable->result()` to get all your results formatted in datatables style.\r\n\r\n##Building your own custom driver\r\nCheckout the abstract driver class if you haven't already. Make sure that your driver implements all the methods it needs. At a later date there will be a detailed wiki entry on how to create custom database drivers with ease. For now take a look at how the two pre-packaged drivers work to get an idea how your driver needs to get data and return it.\r\n\r\n#Roadmap\r\n- Support for dataTables 1.10.x options\r\n- A query extension allowing for query manipulation after datatables has taken a count of the fields in the database\r\n\r\n#Testing\r\nThere are a full suite of tests written to make sure that this project works as expected. If you want to run the tests you will need to be running on a Linux OS with SQLite3 and PHPUnit. The tests are portable to mySQL however as it stands there is no support for it in the project. MongoDB is required for mongo driver tests.\r\n\r\n#Changelog\r\n**0.3.1**\r\n- Bug fixes to drivers specifically Laravel query builders\r\n- Comprehensive module and acceptance tests added to qualify the above\r\n- Drivers return raw data not formatted data\r\n- Response object now holds the responsibility to format data\r\n- Response tests added\r\n\r\n**0.3.0**\r\n- Config added, package now needs config published to set database defaults for custom drivers\r\n- Interpreters updated to accept field names\r\n- Database driver interface added\r\n- MongoDB database driver added\r\n\r\n\r\n**0.2.6**\r\n- Append interpreter added\r\n- Prepend interpreter added\r\n- Closure capability for columns added\r\n\r\n**0.2.0**\r\n- Column interpreter language and decoration now included\r\n- Combine interpreter added\r\n- Driver interface now included for custom driver creation (work in progress)\r\n- Fixed numerous bugs\r\n","google":"UA-51900969-1","note":"Don't delete this file! It's used internally to help with page regeneration."}